<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Cosock</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01-cosock.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="02-spawn.html"><strong aria-hidden="true">2.</strong> Spawn</a></li><li class="chapter-item expanded "><a href="03-select.html"><strong aria-hidden="true">3.</strong> Select</a></li><li class="chapter-item expanded "><a href="04-channels.html"><strong aria-hidden="true">4.</strong> Channels</a></li><li class="chapter-item expanded "><a href="05-run.html"><strong aria-hidden="true">5.</strong> Advanced: Run</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Cosock</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cosock"><a class="header" href="#cosock">Cosock</a></h1>
<p>Cosock is a coroutine runtime written in pure Lua and based on teh popular luasocket library.</p>
<p>The goal of the project is to provide the same interfaces that luasocket provides but wrapped
up in coroutines to allow for concurrent IO.</p>
<p>For example, the following 2 lua programs use luasocket to define a tcp client and server.</p>
<pre><code class="language-lua">--client.lua
local socket = require &quot;socket&quot;
local client = socket.tcp()
client:connect(&quot;0.0.0.0&quot;, 9999)
while true do
    print(&quot;sending ping&quot;)
    client:send(&quot;ping\n&quot;)
    local response = assert(client:receive())
    assert(response == &quot;pong&quot;)
end
</code></pre>
<pre><code class="language-lua">--server.lua
local socket = require &quot;socket&quot;
local server = socket.tcp()
server:bind(&quot;0.0.0.0&quot;, 9999)
server:listen()
print(&quot;listening&quot;, server:getsockname())
local client = server:accept()
while true do    
    local request = assert(client:receive())
    assert(request == &quot;ping&quot;)
    print(&quot;sending pong&quot;)
    client:send(&quot;pong\n&quot;)
end
</code></pre>
<p>If you were to run first <code>lua ./server.lua</code> and then <code>client.lua</code> you should see each terminal print out
their &quot;sending ...&quot; messages forever.</p>
<p>Using cosock, we can actually write the same thing as a single application.</p>
<pre><code class="language-lua">-- client_server.lua
local cosock = require &quot;cosock&quot;
local socket = require &quot;cosock.socket&quot;
local ip = &quot;0.0.0.0&quot;
local server = socket.tcp()
--- Since the client and server are in the same application
--- we can use an OS assigned port and share it across the
--- two tasks, to coordinate the two tasks to start in the order
--- we want, we can use a cosock channel to make sure both tasks
--- have the same port number
local port_tx, port_rx = cosock.channel.new()

--- Spawn a task for handling the server side of the socket
cosock.spawn(function()
    server:bind(ip, 0)
    local _ip, p = server:getsockname()
    port_tx:send(p)
    server:listen()
    local client = server:accept()
    while true do
        local request = assert(client:receive())
        print(string.format(&quot;receieved %q&quot;, request))
        assert(request == &quot;ping&quot;)
        print(&quot;sending pong&quot;)
        client:send(&quot;pong\n&quot;)
    end
end, &quot;server task&quot;)

--- Spawn a task for handling the client side of the socket
cosock.spawn(function()
    --- wait for the server to be ready.
    local port = assert(port_rx:receive())
    local client = socket.tcp()
    client:connect(ip, port)
    while true do    
        print(&quot;sending ping&quot;)
        client:send(&quot;ping\n&quot;)
        local request = assert(client:receive())
        assert(request == &quot;pong&quot;)
    end
end, &quot;client task&quot;)

--- Finally we tell cosock to run our 2 coroutines until they are done
--- which should be forever
cosock.run()
</code></pre>
<p>Now if we run this with <code>lua ./client_server.lua</code> we should see the messages alternate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spawn"><a class="header" href="#spawn">Spawn</a></h1>
<p>At the core of cosock's ability to work is the ability to wrap any operation in a coroutine and
register that with cosock. For this cosock exports the function <code>cosock.spawn</code>. This function takes
2 arguments, first is a function that will be our coroutine, the second is a name for that coroutine.</p>
<p>For example, this is a simple program that will spawn a single coroutine, which will print the current
timestamp and the word &quot;tick&quot; then sleep for 1 second in a loop forever.</p>
<pre><code class="language-lua">--basic_spawn.lua
local cosock = require &quot;cosock&quot;

cosock.spawn(function()
    while true do
        print(cosock.socket.gettime(), &quot;tick&quot;)
        cosock.socket.sleep(1)
    end
end, &quot;clock&quot;)
cosock.run()
</code></pre>
<p>The act of calling <code>cosock.spawn</code> allow us to use the non-blocking <code>cosock.socket.sleep</code> function. This means
we could extend our application to not only print this message every second but use the time this coroutine
is sleeping to perform some other work. Let's extend our little example a bit.</p>
<pre><code class="language-lua">--less_basic_spawn.lua
local cosock = require &quot;cosock&quot;

local function clock_part(name, sleep_first)
    return function()
        if sleep_first then
            cosock.socket.sleep(1)
        end
        while true do
            print(cosock.socket.gettime(), name)
            cosock.socket.sleep(2)
        end
    end
end

cosock.spawn(clock_part(&quot;tick&quot;), &quot;tick-task&quot;)
cosock.spawn(clock_part(&quot;tock&quot;, true), &quot;tock-task&quot;)
cosock.run()
</code></pre>
<p>This time we have changed things up a bit. Instead of defining our coroutine right in the call to <code>cosock.spawn</code>
a local function is defined <code>clock_part</code> which will return a function. This is required because <code>cosock.spawn</code> doesn't
have the ability to forward any arguments initially but by returning a function here we can capture the arguments
to our initial call to <code>clock_part</code>.</p>
<p>This script will essentially just spawn 2 of the same coroutine, which will sleep for 2 seconds and then print the timestamp
along with their name. We then register one named &quot;tick&quot; and one named &quot;tock&quot;. Since we don't want to try and print both
&quot;tick&quot; and &quot;tock&quot; at the same time, for &quot;tock&quot; we sleep for 1 second right at the start.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="select"><a class="header" href="#select">Select</a></h1>
<p>Now that we have covered how to spawn and run coroutines using cosock, lets talk about how we
could handle multiple IO sources in a single coroutine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channels"><a class="header" href="#channels">Channels</a></h1>
<p>Since global variables can be a huge pain to work with across coroutines. Cosock offers a synchronization primitive
called channels. This is a multiple producer single consumer message queue, this means you can have one coroutine own
the receiving half of the queue and pass the sender out to however many coroutines you'd like.</p>
<pre><code class="language-lua">--TODO: provide example
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-overview-of-cosockrun"><a class="header" href="#advanced-overview-of-cosockrun">Advanced Overview of <code>cosock.run</code></a></h1>
<h2 id="global-variables"><a class="header" href="#global-variables">Global Variables</a></h2>
<ul>
<li><code>threads</code>: List of coroutines cosock is aware of
<ul>
<li>This is populated by the first argument to <code>cosock.spawn</code></li>
</ul>
</li>
<li><code>threadnames</code>: A map of coroutine&lt;-&gt;name pairs
<ul>
<li>This is populated by the second argument ot <code>cosock.spawn</code></li>
</ul>
</li>
<li><code>threadswaitingfor</code>: A map of coroutine&lt;-&gt;select args
<ul>
<li>Select args have the type <code>{recvr = {&quot;list of cosock sockets&quot;}, sendr = {&quot;list of cosock sockets&quot;}, timeout = 0}</code></li>
<li>This populated by the values provided to <code>coroutine.yield</code> for cosock tasks from a call to <code>cosock.socket.select</code></li>
</ul>
</li>
<li><code>readythreads</code>: A list of coroutines that will be ready on the next pass
<ul>
<li>This is populated by coroutine wak-ups that occur on the current pass</li>
</ul>
</li>
<li><code>socketwrappermap</code>: A map of luasocket&lt;-&gt;cosock socket pairs
<ul>
<li>This map is keyed with the table pointer for the luasocket for easily getting back to a cosock socket when you
only have a luasocket</li>
<li>This gets populated when a cosock socket is included in a select args table</li>
</ul>
</li>
<li><code>threaderrorhandler</code>: Potential error handler function. Not currently settable.</li>
<li><code>timers</code>: A list of <code>timer</code> tables
<ul>
<li>A timer has the shape <code>{timeoutat = &quot;deadline timestamp&quot;, callback = &quot;function to be called at deadline&quot;, ref = &quot;table pointer&quot;}</code></li>
<li><code>timers.set</code>
<ul>
<li>Updates <code>timers</code> to include that value. Also updates a private scoped table named <code>refs</code>
<ul>
<li><code>refs</code> is a map of table pointer&lt;-&gt;timer</li>
</ul>
</li>
</ul>
</li>
<li><code>timers.cancel</code>
<ul>
<li>If the provided table pointer is in <code>refs</code>, remove the <code>callback</code> and <code>ref</code> properties from that table</li>
<li>Set the table pointer key in <code>refs</code> to <code>nil</code></li>
</ul>
</li>
<li><code>timers.run</code>
<ul>
<li>Sort all timeouts by deadline (earliest first)</li>
<li>Pop the timer off the front of the <code>timers</code> list</li>
<li>If that <code>timer.timeoutat</code> is <code>nil</code> or <code>&lt; socket.gettime()</code>
<ul>
<li>Call <code>timer.callback</code></li>
<li>remove this <code>timer</code> from <code>refs</code></li>
</ul>
</li>
<li>If there are any more timeouts left, return how long before that timeout should expire</li>
<li>If there are no more timeouts, return <code>nil</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="run-loop-steps"><a class="header" href="#run-loop-steps">Run loop steps</a></h2>
<ol>
<li>define <code>wakethreads</code></li>
<li>define an empty list of senders (<code>sendt</code>), receivers (<code>recvt</code>) and a <code>timeout</code></li>
<li>pop all <code>readythreads</code> entries into the <code>wakethreads</code></li>
<li>Loop over all threads in <code>wakethreads</code>
<ol>
<li>If <code>coroutine.status</code> for that thread returns &quot;suspended&quot;
<ol>
<li>Clear any timers</li>
<li>Clear any wakers registered with a <code>timeout</code></li>
<li><code>coroutine.resume</code> with the stored <code>recv4</code>, <code>sendr</code> and <code>err</code> arguments</li>
<li>if <code>coroutine.resume</code> returned <code>true</code> in the first position and <code>coroutine.status</code> returns &quot;suspended&quot;
<ol>
<li>re-populate <code>threadswaitingfor[thread]</code> with the 3 other return values from <code>coroutine.resume</code>
<ol>
<li>These should be the <code>recvt</code>, <code>sendt</code> and <code>timeout</code> values that will populate select args</li>
</ol>
</li>
<li>set the waker for all sockets in <code>recvt</code> and <code>sendt</code> to call <code>wake_thread</code> and then unset themselves</li>
<li>if <code>coroutine.resume</code> returned a <code>timeout</code>, create a new timer for this thread which will call <code>wake_thread_err</code> on expirations with the value &quot;timeout&quot;</li>
</ol>
</li>
<li>if <code>coroutine.status</code> returned &quot;dead&quot;
<ol>
<li>If <code>coroutine.resume</code> returned <code>false</code> in the first position and no <code>threaderrorhandler</code> has been set
<ol>
<li>Raise and error
<ol>
<li>If the <code>debug</code> library is available, include a <code>debug.traceback</code> and the second return value from <code>cosock.resume</code></li>
<li>else just raise an error with the second return value from <code>cosock.resume</code></li>
</ol>
</li>
<li>Exit the application
<ol>
<li>This calls <code>os.exit(-1)</code></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>Else, print a warning message if printing is turned on</li>
<li>initialize a variable <code>running</code> to <code>false</code></li>
<li>loop over all <code>threads</code>, if <code>coroutine.status</code> doesn't return &quot;dead&quot; for any, set <code>running</code> to <code>true</code></li>
<li>If <code>running</code> is <code>false</code> and <code>readythreads</code> is empty
<ol>
<li>Exit the run loop</li>
</ol>
</li>
<li>Loop over all the values in <code>threadswaitingfor</code>
<ol>
<li>Insert the luasockets on any <code>sendr</code> or <code>recvr</code> parameters to the loop local variables <code>sendt</code> and <code>recvt</code></li>
<li>Populate <code>socketwrappermap</code> with any <code>sendr</code> or <code>recvr</code>s</li>
</ol>
</li>
<li>Call <code>timers.run</code></li>
<li>If <code>readythreads</code> is not empty
<ol>
<li>Set <code>timeout</code> to <code>0</code></li>
</ol>
</li>
<li>If <code>timeout</code> is falsy and <code>recvt</code> is empty and <code>sendt</code> is empty
<ol>
<li>Raise an error that cosock.select was called with no sockets and no timeouts</li>
</ol>
</li>
<li>Call luasocket's <code>socket.select</code> with our loops <code>recvt</code>, <code>sendt</code> and <code>timeout</code></li>
<li>If <code>socket.select</code> returns a value in the 3rd position and that value is not <code>&quot;timeout&quot;</code>
<ol>
<li>Raise an error with that return value</li>
</ol>
</li>
<li>Loop over the <code>recvr</code> (1st) return from <code>socket.select</code>
<ol>
<li>Look up the <code>cosock.socket</code> from <code>socketwrappermap</code></li>
<li>call <code>skt:_wake(&quot;recvr&quot;)</code></li>
</ol>
</li>
<li>Loop over the <code>sendr</code> (2nd) return from <code>socket.select</code>
<ol>
<li>Look up the <code>cosock.socket</code> from <code>socketwrappermap</code></li>
<li>call <code>skt:_wake(&quot;sendr&quot;)</code></li>
</ol>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
